---
title: DIY 手绘贴纸项目的安全设计与攻防实践
slug: 前端安全
summary:  DIY 手绘贴纸项目的安全设计与攻防事件
date: '2025-12-29'
featured_image_url: /blogs/safe/cover.webp
tags:
  - 前端安全
---


## 项目背景与系统边界

### 1. 项目核心功能

用户可以:
- 手绘任意图案 (自由轨迹)
- 添加系统内置贴纸
- 输入自定义文字
- 生成最终可下载/打印的贴纸图片


### 2. 风险类型

- `请求重放攻击`：用户捕获前端请求后，不断重放试错，以规避规则或自动化尝试生成绘画内容。

- `贴纸接口劫持`：用户在客户端层篡改贴纸列表接口，使返回内容被替换为其自定义贴纸 URL，实现未授权内容注入。

- `字体替换攻击（字符矢量伪造）`：在 Windows 虚拟机中，用户通过篡改系统字体，将某个 Unicode 字符替换成自定义矢量图，从而绕过字符白名单、敏感词检测等规则。

- `脚本化绘画（Python 模拟鼠标）`：用户使用自动化脚本（如 Python + PyAutoGUI）模拟鼠标行为，实现自动绘画、批量攻击或异常高频率操作。

后续的安全设计, 都是围绕上面的风险类型所展开

### 3.请求重放攻击

`为什么前端限制毫无意义`

> 工程事实: 只要请求能从客户端发出去, 它就一定能被完整复现. 所以前端做的任何 `次数限制 / 校验逻辑`, 在重放攻击面前都只是 `用户体验优化`

前端能限制的是 `UI行为`, 但是攻击者可能攻击的是 `接口能力`.

`解决思路`

- 一次性Token
- 请求签名 + 时间窗

1. 一次性Token -> 

> 解决: 请求次数的问题

设计流程

```text
前端: 申请生成 token
    ⬇️
服务端: 签发 token
    ⬇️
前端: 携带 token 调用生成接口
    ⬇️
服务端: 校验 + 立即失效
```

`token绑定信息`

userId、场景类型(DIY贴纸)、创建时间、

即使有 token, 攻击者仍然可能：改参数、改内容、延迟几小时再重放


2. 请求签名 + 时间窗（防参数篡改 & 延迟重放）

> 解决: 请求内容是否被篡改、是否被延迟重放

```js
sign = HMAC(
  token +
  payload_hash +
  timestamp +
  nonce,
  secret
)
```

| 防护        | 解决问题    |
| --------- | ------- |
| `sign`      | 防参数篡改   |
| `timestamp` | 防延迟重放   |
| `nonce`     | 防瞬时多次重放 |


前端签名, 后端验签, 并检查: 1. 是否在合理时间窗口内(3-10s内) 2. nonce是否重复使用

```tsx
payloadHash = sha256(JSON.stringify(payload))

timestamp = currentUnixTime()
nonce = randomUUID()

sign = HMAC_SHA256(
    token + payloadHash + timestamp + nonce,
    SECRET_KEY
)

POST /api/sticker/generate
{
  token: token,
  payload: payload,
  timestamp: timestamp,
  nonce: nonce,
  sign: sign
}
```


### 4.贴纸接口劫持 

问题现象: `用户劫持接口`、`篡改返回值`

解决思路: 进行贴纸安全校验, 强制校验贴纸 `CDN` 白名单
- 操作贴纸（插入、编辑、渲染）时，必须对贴纸资源进行 `服务端验证`：
  - 路径只能来自官方 CDN 域名，如 xxx.cdn.com/...
  - 文件名、文件 hash 需与官方贴纸库匹配。
  - 不允许用户传入第三方 URL 或本地路径。
- 即便用户劫持接口、篡改返回值，前端添加贴纸的动作仍会被拒绝，从而彻底封堵自定义贴纸注入风险。

在贴纸系统中，我把前端渲染和服务端生成彻底拆开。前端在交互阶段可以使用 URL 渲染，但在最终生成阶段只提交 stickerId 和操作参数
服务端通过 stickerId 映射官方资源并完成合成，从架构上保证即便前端被劫持，最终产物仍然是可信的。

```text
┌────────────┐
│   用户     │
└─────┬──────┘
      │
      ▼
┌──────────────────────┐
│ 前端画布（不可信层） │
│ - 绘画               │
│ - 拖拽贴纸           │
│ - 本地渲染           │
└─────┬────────────────┘
      │ 只提交 stickerId + 操作参数
      ▼
┌──────────────────────┐
│   API 网关 / 接入层   │
│ - 鉴权               │
│ - 限流               │
│ - 签名校验           │
└─────┬────────────────┘
      ▼
┌──────────────────────┐
│   贴纸生成服务端     │
│（可信计算层）        │
│ - 校验 stickerId     │
│ - 贴纸库映射         │
│ - CDN 拉取 + hash    │
│ - 服务端渲染         │
└─────┬────────────────┘
      ▼
┌──────────────────────┐
│   官方贴纸资源库     │
│ - stickerId          │
│ - path               │
│ - hash               │
│ - status             │
└─────┬────────────────┘
      ▼
┌──────────────────────┐
│   官方 CDN            │
│ - 只读资源            │
└──────────────────────┘
```

提交给服务端的正确数据结构

❌ 错误方式（永远不要）
```JSON
{
  "stickers": [
    {
      "url": "https://evil.com/xxx.png",
      "x": 120,
      "y": 300
    }
  ]
}
```

✅ 正确方式（你现在的设计）
```JSON
{
  "stickers": [
    {
      "stickerId": "sticker_001",
      "x": 120,
      "y": 300,
      "scale": 1.2,
      "rotate": 15
    }
  ]
}
```

#### 服务端完整处理流程

1. 校验 stickerId 是否官方
2. 服务端决定用哪个资源
3. 从官方 CDN 加载资源
4. 服务端合成最终贴纸
5. 生成最终图片 / PDF / 贴纸文件


#### 设计理由

攻击 1: 我前端换成自定义贴纸 ->  ❌ 服务端根本不认 URL

攻击 2: 我接口劫持返回第三方 URL ->  ❌ 成阶段不会用它

攻击 3: 我篡改提交参数 -> ❌ 服务端拒绝


### 5.前端字符重建 —— 禁止字体替换伪造字符

`字体替换攻击`。攻击者可能在客户端或虚拟机中替换系统字体文件，把正常字符渲染成任意图形，从而绕过敏感词检测或注入不合规内容。

#### 问题本质

```text
字符 = Unicode
显示 = 系统字体
```

然而
- Unicode 只是字符编号
- 真正显示的是字体文件里的矢量轮廓（glyph）

#### 如何防御

- `前端重建字符`: 不依赖客户端系统字体，将字符渲染过程完全掌控在前端
- `明确字符身份`: 将用户输入转换为 Unicode codePoint 数组，例如：
```js
Array.from("我们").map(c => c.codePointAt(0)) // [25105, 20204]
```

- `使用内置字体或矢量字形库`: 前端使用项目内置字体文件或矢量库，而非依赖系统字体

- `Canvas / 矢量路径绘制`: 将字符转换为矢量路径绘制，而不是直接用系统 fillText 渲染。

字符 → 矢量路径 → Canvas

```js
const codePoints = Array.from(text).map(c => c.codePointAt(0))

codePoints.forEach(cp => {
  const glyph = font.getGlyph(cp)      // 内置字形库查找
  const path = glyph.getPath(x, y)    // 生成矢量路径
  path.draw(ctx)                       // Canvas 渲染
})
```

